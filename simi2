#!/usr/bin/env perl

use warnings FATAL => 'all';
use strict;
use 5.10.0;

# FIXME: invert subdiffs (when should subdiffing be done?)

##############################################################################

# FIXME: add note about missing newline at end
sub read_file {
    my ($file) = @_;
    open my $in, $file or die "Cannot open file '$file' for reading: $!\n";
    my @data = <$in>;
    close $in, $file or die "Cannot close file '$file' after reading: $!\n";
    return wantarray
        ? do { s/\r?\n\z// foreach @data; @data }
        : join "", @data;
}

{
    package Local::Output;

    sub new {
        my ($class, %arg) = @_;
        return bless({
            '+'   => "",                       # ANSI terminal hilite strings
            '-'   => "",
            ""    => "",
            reset => "",
        }, $class)->set(%arg);
    }

    sub set {
        my ($self, %arg) = @_;
        foreach (keys %arg) {
            $self->{$_} = $arg{$_};
        }
        foreach (qw( old_width new_width )) {
            die "Option '$_' must set to a number, not " .
                (defined($self->{$_}) ? "'$self->{$_}'" : "undef") . "\n"
                    if ($self->{$_} // '') !~ /^\d+$/;
        }
        return $self;
    }

    sub output {
        my ($self, $change, $old, $new, $string) = @_;
        printf(
            "%$self->{old_width}s %$self->{new_width}s $self->{$change}%1s %s$self->{reset}\n",
            $old,
            $new,
            $change,
            $string,
        );
    }
}


##############################################################################

my %opt = (
    color => 1,
    all   => 0,
);

if (@ARGV != 2) {
    die "$0: Bad number of arguments\n",
        "Usage: diffy FILE1 FILE2\n";
}


my @old = read_file shift;
my @new = read_file shift;
my ($old, $new) = (1, 1);                      # line count

use Algorithm::Diff 'sdiff';
my @sdiff = sdiff(\@old, \@new);

my $out = Local::Output->new(
    old_width => length(scalar @old),
    new_width => length(scalar @new),
);

if ($opt{color}) {
    $out->set(
        '+'   => "\e[32m",
        '-'   => "\e[31m",
        reset => "\e[m"
    );
}

my $line = 0;
foreach (@sdiff) {
    my ($change, $oldstr, $newstr) = @$_;

    if ($change eq "u") {                      # unchanged
        if ($opt{all}) {
            $out->output("", $old, $new, $oldstr);
        } elsif (!$line) {
            say "------------------------------";
            $line = 1;
        }
        $old += 1;
        $new += 1;
        next;
    }
    $line = 0;
    if ($change eq "c") {                      # changed
        $out->output("-", $old, "", $oldstr);
        $out->output("+", "", $new, $newstr);
        $old += 1;
        $new += 1;
    } elsif ($change eq "+") {                 # added
        $out->output("+", "", $new, $newstr);
        $new += 1;
    } elsif ($change eq "-") {                 # removed
        $out->output("-", $old, "", $oldstr);
        $old += 1;
    }
}

#[eof]
